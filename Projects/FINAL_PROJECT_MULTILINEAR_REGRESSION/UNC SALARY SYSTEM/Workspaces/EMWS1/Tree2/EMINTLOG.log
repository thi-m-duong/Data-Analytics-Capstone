NOTE: PROCEDURE PRINTTO used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      


18273      %let em_Train = Y;
18274      %let em_Report = Y;
18275      %let em_Score = Y;
18276      %let em_Run = Y;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMODL.TREE_TRAINMACROS.SOURCE.
18278     +%Macro EM_CheckBinaryTargetLevel(indata=, target=,  nLevel= );
18279     +  %global &nLevel;
18280     +  proc dmdb batch data=&indata
18281     +    classout=_tmp_dmdbout;
18282     +    class &target;
18283     +  run;
18284     +  data _tmp_dmdbout;
18285     +    set _tmp_dmdbout;
18286     +    if strip(TYPE) = 'N' and  strip(LEVEL) = '.' then delete;
18287     +    if strip(TYPE) = 'C' and  strip(LEVEL) = '' then delete;
18288     +  run;
18289     +  data _null_;
18290     +    %let dsid = %sysfunc(open(work._tmp_dmdbout));
18291     +    %let _obs = %sysfunc(attrn(&dsid, NOBS));
18292     +    %let dsid = %sysfunc(close(&dsid));
18293     +     call symput("&nLevel", put(&_obs, Best12.));
18294     +  run;
18296     +  proc datasets lib=work nolist;
18297     +     delete _tmp_dmdbout;
18298     +  run;
18299     +  quit;
18300     +%Mend EM_CheckBinaryTargetLevel;
18303     +%macro em_tree_runTreeProcedure(indata= , multipleTar= , intFlag= );
18305     +  /* determine the number of obs in training data */
18306     +  proc sql;
18307     +    reset noprint;
18308     +    select count(*) into :em_nobs from &indata;
18309     +  quit;
18311     +  /* determine the number of input variables */
18312     +  %let numinputs = %eval(&EM_NUM_BINARY_INPUT + &EM_NUM_NOMINAL_INPUT + &EM_NUM_ORDINAL_INPUT + &EM_NUM_INTERVAL_INPUT+
18313     +                         &EM_NUM_BINARY_REJECTED + &EM_NUM_NOMINAL_REJECTED + &EM_NUM_ORDINAL_REJECTED + &EM_NUM_INTERVAL_REJECTED);
18315     +  /* retrieve targetEvent from decmeta */
18316     +  %let targetEvent=;
18317     +  %if "%EM_TARGET_LEVEL" ne "INTERVAL" %then %do;
18318     +    %if %sysfunc(exist(&EM_DEC_DECMETA)) %then %do;
18319     +      data _null_;
18320     +       set &EM_DEC_DECMETA(where=(_TYPE_="TARGET"));
18321     +       call symput('targetEvent', strip(tranwrd(EVENT,'"','""')));
18322     +      run;
18323     +    %end;
18324     +  %end;
18326     +  /* create targetTable if multipleTar eq Y */
18327     +  data temptarget;
18328     +    set &EM_DATA_VARIABLESET;
18329     +    where ROLE="TARGET" AND LEVEL^="ORDINAL";
18330     +  run;
18332     + /* data sets */
18333     + %EM_GETNAME(key=OUTSTATS,      type=DATA);
18334     + %EM_GETNAME(key=EMTREE,        type=DATA);
18335     + %EM_GETNAME(key=OUTOBSIMP,     type=DATA);
18336     + %EM_GETNAME(key=OUTSEQ,        type=DATA);
18337     + %EM_GETNAME(key=OUTIMPORT,     type=DATA);
18338     + %EM_GETNAME(key=OUTNODES,      type=DATA);
18339     + %EM_GETNAME(key=OUTSUMMARY,    type=DATA);
18340     + %EM_GETNAME(key=OUTTOPOLOGY,   type=DATA);
18341     + %EM_GETNAME(key=OUTPATH,       type=DATA);
18342     + %EM_GETNAME(key=OUTRULES,      type=DATA);
18344     + /* files */
18345     + %EM_GETNAME(key=TREEFLOW, type=FILE, extension=sas);
18346     + %EM_GETNAME(key=TREEPUBLISH, type=FILE, extension=sas);
18348     + /* turn on pmml if requested */
18349     + %let nnpmml=0;
18350     + %if %symexist(EM_PMML) %then %do;
18351     +    %if %upcase(&EM_PMML)=Y or %upcase(&EM_PMML)=YES %then %do;
18352     +       %let nnpmml=1;
18354     +       ods pmml file="&EM_FILE_EMPMML" encoding="UTF-8";
18355     +%end;
18357     + %let numClassTarget = %sysevalf(&EM_NUM_BINARY_TARGET + &EM_NUM_NOMINAL_TARGET + &EM_NUM_ORDINAL_TARGET);
18359     + %if &nnpmml or &numClassTarget %then %do;
18361     +       /* create dmdb needed for pmml generation */
18362     +       %let tree_maxlevel = 512;
18363     +       %if %symexist(EM_TRAIN_MAXLEVELS) %then %do;
18364     +         %if &EM_TRAIN_MAXLEVELS ne %then %do;
18365     +           %let tree_maxlevel = &EM_TRAIN_MAXLEVELS;
18366     +         %end;
18367     +       %end;
18368     +       %if &tree_maxlevel gt 0 %then %do;
18369     +           %let tree_maxlevel=%sysevalf(&tree_maxlevel+1);
18370     +          %let tree_maxlevel=%sysfunc(max(3, &tree_maxlevel ));
18371     +       %end;
18373     +       %let targetOrderString =;
18374     +       %let targetString = ;
18375     +       data _null_;
18376     +          length orderString nameString $10000;
18377     +          retain orderString nameString;
18378     +          set &em_data_variableset end=eof;
18379     +          %if "&EM_PROPERTY_USEMULTIPLETARGET" eq "Y" and ^&em_num_ordinal_target %then %do;
18380     +              where ROLE="TARGET" and LEVEL in("BINARY", "NOMINAL");
18381     +          %end;
18382     +          %else %do;
18383     +              where ROLE="TARGET" and LEVEL in("BINARY", "NOMINAL", "ORDINAL") and USE ='Y';
18384     +          %end;          select(order);
18385     +            when('')        order ='DESC';
18386     +            when('FMTASC')  order='ASCFMT';
18387     +            when('FMTDESC') order='DESFMT';
18388     +            otherwise;
18389     +          end;
18390     +          orderString = trim(orderString)!!' '!!trim(NAME)!!'('!!trim(order)!!')';
18391     +          nameString = trim(nameString)!!' '!!trim(NAME);
18393     +          if eof then do;
18394     +             call symput('targetOrderString', trim(orderString));
18395     +             call symput('targetString', trim(nameString));
18396     +          end;
18397     +       run;
18399     +       %let arborkluge= "work._treeDMDB";
18401     +       proc dmdb batch data=&indata
18402     +       %if &nnpmml %then %do;
18403     +           PMML
18404     +       %end;
18405     +        dmdbcat=_treeDMDB classout=classout varout=varout maxlevel=&tree_maxlevel;
18408     +   %if &nnpmml %then %do;
18409     +        %if "%EM_ID" ne "" %then %do;
18410     +          id %EM_ID;
18411     +        %end;
18412     +        %if &EM_NUM_CLASS gt 0 %then %do;
18413     +          class %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
18414     +               %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
18415     +               &targetOrderString;
18416     +        %end;
18417     +        %if &EM_NUM_INTERVAL gt 0 %then %do;
18418     +          var %EM_INTERVAL;
18419     +        %end;
18420     +        target &targetString %EM_INTERVAL_TARGET;
18421     +        %if "%EM_FREQ" ne "" %then %do;
18422     +          freq %EM_FREQ;
18423     +        %end;
18424     +  %end;
18425     +  %else %do;
18426     +      class  &targetOrderString;
18427     +      target &targetString %EM_INTERVAL_TARGET;
18428     +  %end;
18429     +       run;
18430     +       quit;
18432     +       proc datasets lib=work nolist;
18433     +          delete classout varout;
18434     +       run;
18435     +       quit;
18437     +    %end;
18438     + %end;
18440     + /* run Arbor procedure */
18441     + %if "&EM_PROPERTY_FREEZE" eq "N" and "&EM_PROPERTY_IMPORTMODEL" eq "N" %then %do;
18442     +  proc arbor data=&INDATA
18444     +  %if "&EM_PROPERTY_LEAFSIZE" ne "" %then %do;
18445     +    Leafsize = &EM_PROPERTY_LEAFSIZE
18446     +  %end;
18448     +  %if (("&EM_PROPERTY_SPLITSIZE" ne ".") AND (&EM_PROPERTY_SPLITSIZE lt &em_nobs)) %then %do;
18449     +    Splitsize = &EM_PROPERTY_SPLITSIZE
18450     +  %end;
18452     +  %if "&EM_PROPERTY_MINCATSIZE" ne "" %then %do;
18453     +    MinCatSize = &EM_PROPERTY_MINCATSIZE
18454     +  %end;
18456     +  %if "&EM_PROPERTY_MAXBRANCH" ne "" %then %do;
18457     +    MaxBranch = &EM_PROPERTY_MAXBRANCH
18458     +  %end;
18460     +  %if "&EM_PROPERTY_MAXDEPTH" ne "" %then %do;
18461     +    MaxDepth = &EM_PROPERTY_MAXDEPTH
18462     +  %end;
18464     +  %if (("%EM_TARGET_LEVEL" eq "NOMINAL") OR ("%EM_TARGET_LEVEL" eq "BINARY")) %then %do;
18465     +    %let Criterion = &EM_PROPERTY_NOMINALCRITERION;
18466     +  %end;
18467     +  %else %if "%EM_TARGET_LEVEL" eq "ORDINAL" %then %do;
18468     +    %let Criterion = &EM_PROPERTY_ORDINALCRITERION;
18469     +  %end;
18470     +  %else %if "%EM_TARGET_LEVEL" eq "INTERVAL" %then %do;
18471     +    %let Criterion = &EM_PROPERTY_INTERVALCRITERION;
18472     +  %end;
18474     +  %if (("&criterion" eq "PROBCHISQ") or ("&criterion" eq "PROBF")) %then %do;
18475     +    %if "&EM_PROPERTY_SIGLEVEL" ne "" %then %do;
18476     +      alpha = &EM_PROPERTY_SIGLEVEL
18477     +    %end;
18478     +  %end;
18480     +  %if (("&EM_PROPERTY_KASS" eq "Y") OR ("&EM_PROPERTY_DEPTH" eq "Y") or ("&EM_PROPERTY_INPUTS" eq "Y")) %then %do;
18481     +    %if (("&Criterion" eq "PROBCHISQ") OR ("&Criterion" eq "PROBF") OR ("&Criterion" eq "DEFAULT")) %then %do;
18482     +      %if (("&EM_PROPERTY_KASS" eq "Y") or ("&EM_PROPERTY_DEPTH" eq "Y")) %then %do;
18483     +        %if "&EM_PROPERTY_KASSAPPLY" eq "BEFORE" %then %let chaid = CHAIDBEFORE;
18484     +        %else %if "&EM_PROPERTY_KASSAPPLY" eq "AFTER" %then %let chaid = CHAIDAFTER;
18486     +        padjust =
18487     +        %if "&EM_PROPERTY_KASS" eq "Y" %then %do;
18488     +          &chaid
18489     +        %end;
18490     +        %if "&EM_PROPERTY_DEPTH" eq "Y" %then %do;
18491     +          DEPTH
18492     +        %end;
18493     +      %end;
18494     +      %if "&EM_PROPERTY_INPUTS" eq "Y" %then %do;
18495     +         %let num_inputs = %sysfunc(min(&numinputs, &EM_PROPERTY_NUMINPUTS));
18496     +         pvars = &num_inputs
18497     +      %end;
18498     +    %end;
18499     +  %end;
18500     +  %else %do;
18501     +      %if (("&Criterion" eq "PROBCHISQ") OR ("&Criterion" eq "PROBF") OR ("&Criterion" eq "DEFAULT")) %then %do;
18502     +         padjust = NONE
18503     +      %end;
18504     +  %end;
18506     +  %if "&EM_PROPERTY_NRULES" ne "" %then %do;
18507     +    %let num_nrules = %sysfunc(min(&numinputs, &EM_PROPERTY_NRULES));
18508     +    Maxrules = &num_nrules
18509     +  %end;
18511     +  %if "&EM_PROPERTY_NSURRS" ne "" %then %do;
18512     +    %let num_nsurrs = %sysfunc(min((&numinputs-1), &EM_PROPERTY_NSURRS));
18513     +    Maxsurrs = &num_nsurrs
18514     +  %end;
18516     +  %if "&EM_PROPERTY_MISSINGVALUE" ne "" %then %do;
18517     +     Missing=&EM_PROPERTY_MISSINGVALUE
18518     +  %end;
18520     +  %if "&EM_PROPERTY_USEVARONCE" eq "Y" %then %do;
18521     +     USEVARONCE
18522     +  %end;
18524     +  %if "&EM_PROPERTY_EXHAUSTIVE" ne "" %then %do;
18525     +    Exhaustive=&EM_PROPERTY_EXHAUSTIVE
18526     +  %end;
18529     +  %if (("&multipleTar" eq "N") AND ("%EM_TARGET_LEVEL" ne "INTERVAL")) %then %do;
18530     +    event = "&targetEvent"
18531     +  %end;
18533     +  %if "&EM_PROPERTY_USEDECISION" eq "Y" %then %do;
18534     +     DECSEARCH
18535     +  %end;
18537     +  %if "&EM_PROPERTY_USEPRIORS" eq "Y" %then %do;
18538     +     PRIORSSEARCH
18539     +  %end;
18541     +  %if &arbor_1 ne %then %do;
18542     +    &arbor_1
18543     +  %end;
18545     +  %if &em_arbor ne %then %do;
18546     +     &em_arbor
18547     +  %end;
18548     +  ;
18549     + %end;
18550     + %else %if "&EM_PROPERTY_IMPORTMODEL" eq "Y"  %then %do;
18551     +     proc arbor data=&INDATA inmodel=&EM_PROPERTY_ImportedTreeData refreshtrain;
18552     +       interact;
18553     + %end;
18554     + %else %if "&EM_PROPERTY_FREEZE" eq "Y" %then %do;
18555     +   %if %sysfunc(exist(&EM_USER_EMTREE)) ne 1 %then %do;
18556     +    %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOTREEDATASET;
18557     +    %put &em_codebar;
18558     +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, emtool.notreedataset_err, NOQUOTE));
18559     +    %put &errormsg;
18560     +    %put &em_codebar;
18561     +    %goto doendm;
18562     +   %end;
18563     +   %else %do;
18564     +     proc arbor data=&INDATA inmodel=&EM_USER_EMTREE refreshtrain;
18565     +       interact;
18566     +   %end;
18567     + %end;
18569     + %else %do;
18570     +   %if %sysfunc(exist(&EM_USER_BROWSETREE)) ne 1 %then %do;
18571     +    %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOTREEDATASET;
18572     +    %put &em_codebar;
18573     +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, emtool.notreedataset_err, NOQUOTE));
18574     +    %put &errormsg;
18575     +    %put &em_codebar;
18576     +    %goto doendm;
18577     +   %end;
18578     +   %else %do;
18579     +      proc arbor data=&INDATA inmodel=&EM_USER_BROWSETREE refrestrain;
18580     +        interact;
18581     +   %end;
18582     + %end;
18584     + %if "&EM_PROPERTY_FREEZE" eq "N" and "&EM_PROPERTY_IMPORTMODEL" eq "N" %then %do;
18585     +    %if %eval(&EM_NUM_INTERVAL_INPUT + &EM_NUM_INTERVAL_REJECTED) gt 0 %then %do;
18586     +      input %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED/ level = interval;
18587     +    %end;
18589     +    %if  %eval(&EM_NUM_NOMINAL_INPUT + &EM_NUM_NOMINAL_REJECTED) gt 0 %then %do;
18590     +      input %EM_NOMINAL_INPUT %EM_NOMINAL_REJECTED / level = nominal;
18591     +    %end;
18593     +    %if %eval(&EM_NUM_BINARY_INPUT + &EM_NUM_BINARY_REJECTED) gt 0 %then %do;
18594     +      input %EM_BINARY_INPUT %EM_BINARY_REJECTED / level = nominal;
18595     +    %end;
18597     +    %if %eval(&EM_NUM_ORDINAL_INPUT + &EM_NUM_ORDINAL_REJECTED) gt 0 %then %do;
18598     +      input %EM_ORDINAL_INPUT %EM_ORDINAL_REJECTED/ level = ordinal;
18599     +    %end;
18601     +    %if "%EM_FREQ" ne "" %then %do;
18602     +       freq %EM_FREQ;
18603     +    %end;
18605     +    %if "&multipleTar" eq "Y" %then %do;
18606     +       /* cycle through all target vars in variableset */
18607     +       %let tdsid = %sysfunc(open(temptarget));
18608     +       %if &tdsid %then %do;
18609     +          %let n_var = %sysfunc(varnum(&tdsid, NAME));
18610     +          %let n_lvl = %sysfunc(varnum(&tdsid, LEVEL));
18611     +          %do %while(^ %sysfunc(fetch(&tdsid)));
18612     +             %let var = %sysfunc(getvarc(&tdsid, &n_var));
18613     +             %let lvl = %sysfunc(getvarc(&tdsid, &n_lvl));
18614     +             target &var / level = &lvl
18615     +             %if (("&lvl" eq "BINARY") or ("&lvl" eq "NOMINAL")) %then %do;
18616     +               Criterion=&EM_PROPERTY_NOMINALCRITERION;
18617     +             %end;
18618     +             %else %if "&lvl" eq "INTERVAL" %then %do;
18619     +               Criterion=&EM_PROPERTY_INTERVALCRITERION;
18620     +             %end;
18621     +             %else %if "&lvl" eq "ORDINAL" %then %do;
18622     +               Criterion=&EM_PROPERTY_ORDINALCRITERION;
18623     +             %end;
18624     +          %end;
18625     +          %if &tdsid %then %let tdsid=%sysfunc(close(&tdsid));
18626     +       %end;
18627     +       useTarget variable = %EM_TARGET;
18628     +    %end;
18629     +    %else %do;
18630     +      target %EM_TARGET / level = %EM_TARGET_LEVEL
18631     +      %if (("%EM_TARGET_LEVEL" eq "BINARY") or ("%EM_TARGET_LEVEL" eq "NOMINAL")) %then %do;
18632     +        Criterion=&EM_PROPERTY_NOMINALCRITERION;
18633     +      %end;
18634     +      %else %if "%EM_TARGET_LEVEL" eq "INTERVAL" %then %do;
18635     +        Criterion=&EM_PROPERTY_INTERVALCRITERION;
18636     +      %end;
18637     +      %else %if "%EM_TARGET_LEVEL" eq "ORDINAL" %then %do;
18638     +        Criterion=&EM_PROPERTY_ORDINALCRITERION;
18639     +      %end;
18640     +    %end;
18642     +    %if "&multipleTar" eq "N" %then %do;
18643     +      &EM_DEC_STATEMENT;
18644     +    %end;
18646     +    Performance &EM_PROPERTY_PERFORMANCE
18647     +    %if "&EM_PROPERTY_NODESAMPLE" ne "" %then %do;
18648     +      nodesize=&EM_PROPERTY_NODESAMPLE
18649     +    %end;
18650     +    ;
18652     +    %if "&intFlag" eq "Y" %then %do;
18653     +       INTERACT Largest;
18654     +       Train maxnewdepth=0;
18655     +    %end;
18657     +       %if "&EM_PROPERTY_ASSESSMEASURE" ne "" %then %do;
18658     +         Assess
18659     +         %if (("&EM_IMPORT_VALIDATE" ne "") AND (%sysfunc(exist(&EM_IMPORT_VALIDATE)) or %sysfunc(exist(&EM_IMPORT_VALIDATE,VIEW)) )) %then %do;
18660     +            %if "&EM_PROPERTY_CV" eq "Y" %then %do;
18661     +              %put &em_codebar;
18662     +              %let errormsg = %sysfunc(sasmsg(sashelp.dmine, novalidationwithcv_note, NOQUOTE));
18663     +              %put &errormsg;
18664     +              %put &em_codebar;
18665     +            %end;
18666     +            %else %do;
18667     +               Validata=&EM_IMPORT_VALIDATE
18668     +            %end;
18669     +         %end;
18670     +         %else %do;
18671     +           NoValidata
18672     +         %end;
18673     +         %if "&EM_PROPERTY_TRAINMODE" ne "INTERACTIVE" %then %do;
18674     +            %if "&EM_PROPERTY_ASSESSMEASURE" eq "PROFIT/LOSS" %then %do;
18675     +               %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='MATRIX'))));
18676     +               %if &dsid %then %do;
18677     +                 %let usenum = %sysfunc(varnum(&dsid, USE));
18678     +                 %do %while(^ %sysfunc(fetch(&dsid)));
18679     +                   %let use = %sysfunc(getvarc(&dsid, &usenum));
18680     +                   %if "&use" eq "Y" %then %let measure=PROFIT;
18681     +                   %else %do;
18682     +                      %if "%EM_TARGET_LEVEL" eq "INTERVAL" %then %let measure = ASE;
18683     +                      %else %let measure= MISC;
18684     +                   %end;
18685     +                 %end;
18686     +               %end;
18687     +               %if &dsid %then %let dsid = %sysfunc(close(&dsid));
18688     +            %end;
18689     +            %else %if "&EM_PROPERTY_ASSESSMEASURE" eq "MISC" %then %do;
18690     +              %if "%EM_TARGET_LEVEL" eq "INTERVAL" %then  %do;
18691     +                 %let measure=ASE;
18692     +              %end;
18693     +              %else %do;
18694     +                 %let measure=MISC;
18695     +              %end;
18696     +            %end;
18697     +            %else %if "&EM_PROPERTY_ASSESSMEASURE" eq "ASE" %then %do;
18698     +              %let measure=ASE;
18699     +            %end;
18700     +            %else %if "&EM_PROPERTY_ASSESSMEASURE" eq "LIFT" %then %do;
18701     +               %let measure = LIFT;
18702     +               %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='MATRIX'))));
18703     +               %if &dsid %then %do;
18704     +                 %let usenum = %sysfunc(varnum(&dsid, USE));
18705     +                 %do %while(^ %sysfunc(fetch(&dsid)));
18706     +                   %let use = %sysfunc(getvarc(&dsid, &usenum));
18707     +                   %if "&use" eq "Y" %then %let measure=LIFTPROFIT;
18708     +                 %end;
18709     +               %end;
18710     +               %if &dsid %then %let dsid = %sysfunc(close(&dsid));
18711     +            %end;
18712     +            measure=&measure
18713     +            %if (("&measure" eq "LIFT") AND ("%EM_TARGET_LEVEL" ne "INTERVAL")) %then %do;
18714     +               event = "&targetEvent"
18715     +            %end;
18716     +            %if (("&measure" eq "LIFT") OR ("&measure" eq "LIFTPROFIT")) %then %do;
18717     +              proportion=&EM_PROPERTY_ASSESSPERCENTAGE
18718     +            %end;
18719     +         %end;
18720     +         %if "&multipleTar" eq "N" %then %do;
18721     +            %if "&EM_PROPERTY_CV" eq "Y" %then %do;
18722     +               CV
18723     +               %if "&EM_PROPERTY_CVNIter" ne "" %then %do;
18724     +                 CVNITer = &EM_PROPERTY_CVNITER
18725     +               %end;
18726     +               %if "&EM_PROPERTY_CVREPEAT" ne "" %then %do;
18727     +                 CVRepeat = &EM_PROPERTY_CVREPEAT
18728     +               %end;
18729     +               %if "&EM_PROPERTY_CVSEED" ne "" %then %do;
18730     +                 CVSeed = &EM_PROPERTY_CVSEED
18731     +               %end;
18732     +            %end;
18733     +         %end;
18734     +       %end;
18735     +      ;
18737     +      %if "&intFlag" ne "Y" %then %do;
18738     +        %if "&EM_PROPERTY_SUBTREE" ne "" %then %do;
18739     +          %if "&EM_PROPERTY_SUBTREE" eq "ASSESSMENT" %then %let subtree=BEST;
18740     +          %else %if "&EM_PROPERTY_SUBTREE" eq "N" %then %let subtree=NLEAVES;
18741     +          %else %if "&EM_PROPERTY_SUBTREE" eq "LARGEST" %then %let subtree=LARGEST;
18743     +          SUBTREE &subtree
18744     +          %if "&subtree" eq "NLEAVES" %then %do;
18745     +            =&EM_PROPERTY_NSUBTREE
18746     +          %end;
18747     +          ;
18748     +        %end;
18750     +       %if (("&EM_PROPERTY_OBSIMPORTANCE" eq "Y") AND ("&multipleTar" eq "N")) %then %do;
18751     +          %if "&EM_USER_OUTOBSIMP" ne "" %then %do;
18752     +            importance data=&INDATA outfit=&EM_USER_OUTOBSIMP nvars=&EM_PROPERTY_NUMSINGLEIMP;
18753     +          %end;
18754     +       %end;
18755     +      %end;
18756     + %end;
18759     + MakeMacro nleaves = nleaves;
18760     + save
18761     + %if "&EM_USER_EMTREE" ne "" %then %do;
18762     +   MODEL=&EM_USER_EMTREE
18763     + %end;
18764     + %if "&EM_USER_OUTSEQ" ne "" %then %do;
18765     +   SEQUENCE=&EM_USER_OUTSEQ
18766     + %end;
18767     + %if "&EM_USER_OUTIMPORT" ne "" %then %do;
18768     +   IMPORTANCE=&EM_USER_OUTIMPORT
18769     + %end;
18770     + %if "&EM_USER_OUTNODES" ne "" %then %do;
18771     +   NODESTAT=&EM_USER_OUTNODES
18772     + %end;
18773     + %if "&EM_USER_OUTSUMMARY" ne "" %then %do;
18774     +   SUMMARY=&EM_USER_OUTSUMMARY
18775     + %end;
18776     + %if "&EM_USER_OUTSTATS" ne "" %then %do;
18777     +   STATSBYNODE=&EM_USER_OUTSTATS
18778     + %end;
18779     + %if "&EM_USER_OUTTOPOLOGY" ne "" %then %do;
18780     +   TOPOLOGY=&EM_USER_OUTTOPOLOGY
18781     + %end;
18782     + %if "&EM_USER_OUTPATH" ne "" %then %do;
18783     +   Pathlistnonmissing=&EM_USER_OUTPATH
18784     + %end;
18785     + %if "&EM_USER_OUTRULES" ne "" %then %do;
18786     +   RULES = &EM_USER_OUTRULES
18787     + %end;
18788     + ;
18790     + %if "&intFlag" ne "Y" %then %do;
18792     +   %let lookupString = ;
18793     +   %if ^%symexist(EM_OPTION) %then
18794     +      %let EM_OPTION=;
18796     +   %if %sysfunc(index(%upcase(&EM_DEBUG), I18N)) or %sysfunc(index(%upcase(&EM_OPTION), I18N)) %then %do;
18797     +      %let lookupString = LOOKUP=SELECT;
18798     +   %end;
18800     +   %let codetext=;
18801     +   %let norescodetxt=;
18803     +   %if "&EM_PROPERTY_DUMMY" eq "Y" %then %do;
18804     +     %let codetext=&codetext DUMMY;
18805     +     %let norescodetxt=&norescodetxt DUMMY;
18806     +   %end;
18807     +   %if "&EM_PROPERTY_LEAFID" ne "Y" %then %do;
18808     +     %let codetext=&codetext NOLEAFID;
18809     +     %let norescodetxt=&norescodetxt NOLEAFID;
18810     +   %end;
18811     +   %if "&EM_PROPERTY_PREDICT" ne "Y" %then %do;
18812     +     %let norescodetxt=&norescodetxt NOPRED;
18813     +   %end;
18815     +   code file="&EM_USER_TREEFLOW" res &codetext group=&emloopid &lookupString;
18816     +   code file="&EM_USER_TREEPUBLISH" nores &norescodetxt group=&emloopid &lookupString;
18818     +   %if &nnpmml %then %do;
18819     +     code pmml;
18820     +   %end;
18822     +   score data=&INDATA out=_NULL_ outfit=work.fit_train role=TRAIN;
18823     +   %if "&EM_IMPORT_VALIDATE" ne "" %then %do;
18824     +     score data=&EM_IMPORT_VALIDATE out=_NULL_ outfit=work.fit_valid role=VALID;
18825     +   %end;
18826     +   %if "&EM_IMPORT_TEST" ne "" %then %do;
18827     +     score data=&EM_IMPORT_TEST out=_NULL_ outfit=work.fit_test role=TEST;
18828     +   %end;
18829     + %end;
18831     + run;
18832     + quit;
18834     + /*%em_checkerror(); */
18835     +  %if %sysfunc(cexist(work._treeDMDB)) %then %do;
18836     +   /* Delete DMDB catalog */
18837     +   proc datasets lib=work nolist;
18838     +       delete _treeDMDB / mt=cat;
18839     +  run;
18840     +  %end;
18842     + %if &nnpmml %then %do;
18843     +    ods pmml close;
18844     + %end;
18846     +  %doendm:
18848     +%mend em_tree_runTreeProcedure;
18850     +%macro em_tree_createFitStats( multipleTar= );
18853     +  /* create targetTable is multipleTar eq Y */
18854     +  data temptarget;
18855     +    set &EM_DATA_VARIABLESET;
18856     +    where ROLE="TARGET";
18857     +  run;
18859     +  %EM_GETNAME(key=EMOUTFIT, type=DATA);
18860     +   data &EM_USER_EMOUTFIT;
18861     +     length target $32;
18862     +     merge work.fit_train
18863     +     %if "&EM_IMPORT_VALIDATE" ne "" %then %do;
18864     +       work.fit_valid
18865     +     %end;
18866     +     %if "&EM_IMPORT_TEST" ne "" %then %do;
18867     +       work.fit_test
18868     +     %end;
18869     +     ;
18870     +     %if "&multipleTar" eq "N" %then %do;
18871     +       target="%EM_TARGET";
18872     +     %end;
18873     +     %else %do;
18874     +       target = _TARGET_;
18875     +     %end;
18876     +     drop _NW_ _SUMW_
18877     +     %if "&EM_IMPORT_VALIDATE" ne "" %then %do;
18878     +        _VSUMW_
18879     +     %end;
18880     +     ;
18881     +   run;
18883     +   %if "&EM_IMPORT_VALIDATE" ne "" %then %do;
18884     +     proc datasets library=work nolist;
18885     +       delete fit_valid;
18886     +     run;
18887     +   %end;
18888     +   %if "&EM_IMPORT_TEST" ne "" %then %do;
18889     +     proc datasets library=work nolist;
18890     +       delete fit_test;
18891     +     run;
18892     +   %end;
18894     +%mend em_tree_createFitStats;
18897     +%macro em_tree_makeEnglishRules;
18899     +  %EM_GETNAME(key=OUTNODES, type=DATA);
18900     +  %EM_GETNAME(key=OUTPATH, type=DATA);
18902     +  /* verify that necessary tables exist and if not, skip processing */
18903     +  %if %sysfunc(exist(&EM_USER_OUTNODES)) ne 1 %then %do;
18904     +    %let EMEXCEPTIONSTRING = exception.server.EMTOOL.GENERICRUNTIMEEXCEPTION;
18905     +    %goto doendm;
18906     +  %end;
18907     +  %if %sysfunc(exist(&EM_USER_OUTPATH)) ne 1 %then %do;
18908     +    %let EMEXCEPTIONSTRING = exception.server.EMTOOL.GENERICRUNTIMEEXCEPTION;
18909     +    %goto doendm;
18910     +  %end;
18912     +  /* determine length of variable in outpath dataset */
18913     +  %let vlength= ;
18914     +  %let dsid = %sysfunc(open(&EM_USER_OUTPATH));
18915     +  %if &dsid ne %then %do;
18916     +    %let varnum = %sysfunc(varnum(&dsid, VARIABLE));
18917     +    %let vlength = %sysfunc(VARLEN(&dsid, &varnum));
18918     +  %end;
18919     +  %if &dsid ne %then %let dsid = %sysfunc(close(&dsid));
18921     +  data tempoutpath;
18922     +    length varname $&vlength;
18923     +    retain varname;
18924     +    set &EM_USER_OUTPATH;
18926     +    if ^missing(variable) then varname=variable;
18927     +    else if ^missing(var_name) then varname=var_name;
18928     +    output;
18929     +  run;
18931     +  /* create an array of generated predicted variable names */
18932     +  %let tree_pred_vars = ;
18933     +  %let tree_pred_label = ;
18934     +  %let numpred= 0;
18935     +  %if %sysfunc(exist(&EM_DEC_DECMETA)) %then %do;
18937     +    data _null_;
18938     +     set &EM_DEC_DECMETA(where=(_TYPE_="PREDICTED")) end=eof;
18939     +     call symput('tree_pred_vars'!!strip(put(_N_, BEST.)), strip(VARIABLE));
18940     +     call symput('tree_pred_label'!!strip(put(_N_, BEST.)), strip(tranwrd(LABEL,'"','""')));
18941     +     if eof then
18942     +       call symput('numpred', strip(put(_N_, BEST.)));
18943     +    run;
18944     +  %end;
18946     +  /* determine if NPRIORS exists in outnodes  */
18947     +  %local nprior_flag;
18948     +  data _null_;
18949     +    set &EM_USER_OUTNODES(obs=2) end=eof;
18950     +    if eof then do;
18951     +      call symput('nprior_flag', strip(put(npriors, best.)));
18952     +    end;
18953     +  run;
18955     +  proc sort data=tempoutpath; by node; run;
18956     +  proc sort data=&EM_USER_OUTNODES out=outnodes; by node; run;
18958     +  data tempoutpath;
18959     +    merge tempoutpath(in=_a) outnodes(keep= node
18960     +    %if "&nprior_flag" ne "." %then %do;
18961     +      NPRIORS
18962     +    %end;
18963     +    %else %do;
18964     +      N
18965     +    %end;
18966     +    %if &numpred gt 0 %then %do;
18967     +      %do i=1 %to &numpred;
18968     +        &&tree_pred_vars&i
18969     +      %end;
18970     +    %end;
18971     +    );
18972     +    by node;
18973     +    if _a;
18974     +  run;
18976     +  proc sort data=tempoutpath; by node descending varname descending numeric_value; run;
18978     +  data _null_;
18979     +    file x;
18980     +    set tempoutpath;
18981     +    by node descending varname;
18982     +    retain origvar oldnode string;
18983     +    length origvar $32 oldnode 8 string $200;
18985     +    if _N_ = 1 then do;
18986     +      origvar = varname;
18987     +      oldnode = node;
18988     +    end;
18990     +    if first.node then do;
18991     +       put "&EM_CODEBAR";
18992     +       put " Node = " node;
18993     +       put "&EM_CODEBAR";
18994     +    end;
18996     +      if first.varname then do;
18997     +         if RELATION ^in ("=", "ISMISSING", "ISNOTMISSING") then do;
18998     +            if MISSING(CHARACTER_VALUE) then do;
18999     +             if NUMERIC_VALUE ne .  then do;
19000     +              if ^first.node then do;
19001     +                string= "AND "|| strip(varname)||" "||strip(relation)||" "||strip(numeric_value);
19002     +              end;
19003     +              else do;
19004     +                string= "if "|| strip(varname)||" "||strip(relation)||" "||strip(numeric_value);
19005     +              end;
19006     +             end;
19007     +            end;
19008     +            else do;
19009     +              if ^first.node then do;
19010     +                string= "AND "|| strip(varname)||" "||strip(relation)||" "||strip(character_value);
19011     +              end;
19012     +              else do;
19013     +                string= "if "|| strip(varname)||" "||strip(relation)||" "||strip(character_value);
19014     +              end;
19015     +             end;
19016     +         end;
19017     +         else if RELATION in ("=") then do;
19018     +            if ^first.node then do;
19019     +              string = "AND "||strip(varname) ||" IS ONE OF: "||character_value;
19020     +            end;
19021     +            else do;
19022     +              string = "if "|| strip(varname) ||" IS ONE OF: "||character_value;
19023     +            end;
19024     +         end;
19025     +         else if RELATION in ("ISMISSING") then do;
19026     +            if ^first.node then do;
19027     +              string = " AND "|| strip(varname) || " equals Missing";
19028     +            end;
19029     +            else do;
19030     +              string = "if "|| strip(varname) ||" equals Missing";
19031     +            end;
19032     +         end;
19033     +         else if RELATION in ("ISNOTMISSING") then do;
19034     +            if ^first.node then do;
19035     +              string = " AND "|| strip(varname) || " equals All Values";
19036     +            end;
19037     +            else do;
19038     +              string = "if "|| strip(varname) ||" equals All Values";
19039     +            end;
19040     +         end;
19041     +         if ^missing(varname) then origvar = varname;
19042     +         oldnode=node;
19044     +      end;
19045     +      else do;
19046     +         if RELATION ^in ("=", "ISMISSING", "ISNOTMISSING") then do;
19047     +          if MISSING(CHARACTER_VALUE) then do;
19048     +           if  NUMERIC_VALUE ne .  then do;
19049     +            if ^MISSING(string) then
19050     +              string= strip(string)||" AND "|| strip(varname)||" "||strip(relation)||" "||strip(numeric_value);
19051     +            else
19052     +              string= " if "|| strip(varname)||" "||strip(relation)||" "||strip(numeric_value);
19053     +           end;
19054     +          end;
19055     +          else do;
19056     +            if ^MISSING(string) then
19057     +              string= strip(string)||" AND "|| strip(varname)||" "||strip(relation)||" "||strip(character_value);
19058     +            else
19059     +              string= " if "|| strip(varname)||" "||strip(relation)||" "||strip(character_value);
19060     +          end;
19062     +         end;
19063     +         else if RELATION in ("=") then do;
19064     +           string = strip(string)||", "||strip(character_value);
19065     +         end;
19066     +         else if RELATION in ("ISMISSING") then do;
19068     +         end;
19069     +         if ^missing(varname) then origvar = varname;
19070     +         oldnode=node;
19071     +      end;
19072     +      if last.varname then do;
19073     +         if RELATION in ("ISMISSING") then do;
19074     +           if ^first.varname then do;
19075     +             string = strip(string) || " or MISSING";
19076     +           end;
19077     +         end;
19078     +         put string;
19079     +         if ^missing(varname) then origvar = varname;
19080     +         oldnode=node;
19081     +      end;
19083     +      if last.node then do;
19084     +         put "then ";
19085     +         put " Tree Node Identifier   = " node;
19087     +         %if "&nprior_flag" ne "." %then %do;
19088     +           put " Number of Observations = " NPRIORS;
19089     +         %end;
19090     +         %else %do;
19091     +           put " Number of Observations = " N;
19092     +         %end;
19094     +         %if &numpred gt 0 %then %do;
19095     +           %do i=1 %to &numpred;
19096     +             put " &&tree_pred_label&i = " &&tree_pred_vars&i;
19097     +           %end;
19098     +         %end;
19100     +         put " ";
19101     +         if ^missing(varname) then origvar = varname;
19102     +         oldnode=node;
19103     +      end;
19105     +  run;
19107     +  proc datasets lib=work nolist;
19108     +    delete tempoutpath outnodes;
19109     +  run;
19111     +  %doendm:
19112     +%mend em_tree_makeEnglishRules;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


NOTE: There were 1 observations read from the data set EMWS1.TREE2_VARIABLESET.
      WHERE (ROLE='TARGET') and (LEVEL not = 'ORDINAL');
NOTE: The data set WORK.TEMPTARGET has 1 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: 1646789 kilobytes of physical memory.
NOTE: Will use 6616 out of 6616 training cases.
NOTE: Using memory pool with 146240512 bytes.
NOTE: No new nodes created.
NOTE: The subtree sequence contains 1 subtrees. The largest has 1 nodes and 1 leaves.
NOTE: Using subtree with 1 nodes and 1 leaves.
NOTE: Created macro variable NLEAVES equal to 1.
NOTE: The data set EMWS1.TREE2_OUTIMPORT has 12 observations and 6 variables.
NOTE: The data set EMWS1.TREE2_EMTREE has 131 observations and 4 variables.
NOTE: The data set EMWS1.TREE2_OUTNODES has 1 observations and 16 variables.
NOTE: The data set EMWS1.TREE2_OUTPATH has 0 observations and 7 variables.
NOTE: The data set EMWS1.TREE2_OUTRULES has 0 observations and 6 variables.
NOTE: The data set EMWS1.TREE2_OUTSEQ has 1 observations and 18 variables.
NOTE: The data set EMWS1.TREE2_OUTSTATS has 6 observations and 4 variables.
NOTE: The data set EMWS1.TREE2_OUTSUMMARY has 10 observations and 3 variables.
NOTE: The data set EMWS1.TREE2_OUTTOPOLOGY has 1 observations and 5 variables.


NOTE: There were 6616 observations read from the data set EMWS1.PART_TRAIN.
NOTE: The data set WORK._NAMEDAT has 1 observations and 5 variables.
NOTE: PROCEDURE ARBOR used (Total process time):
      real time           0.46 seconds
      cpu time            0.07 seconds
      

NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: EXPLOREOBS EMWS1.Part_TRAIN : vars= 16 : recl= 224 : max=20000 : def= 2000

NOTE: There were 131 observations read from the data set EMWS1.TREE2_EMTREE.
NOTE: The data set EMWS1.TREE2_BROWSETREE has 131 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      


